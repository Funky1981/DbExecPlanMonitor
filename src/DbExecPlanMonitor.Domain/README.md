# DbExecPlanMonitor.Domain

The pure domain layer for execution plan monitoring. Contains entities, value objects, and interfaces with **zero external dependencies**.

## Overview

This layer models SQL Server query performance monitoring:
- Track queries and their execution plans
- Establish performance baselines
- Detect regressions when performance degrades
- Identify resource hotspots
- Suggest remediation actions

## Entities

### Hierarchy

```
DatabaseInstance
└── MonitoredDatabase
    └── QueryFingerprint
        ├── ExecutionPlanSnapshot
        │   └── PlanMetricSample
        ├── PlanBaseline
        └── RegressionEvent
            └── RemediationSuggestion

Hotspot (standalone, references QueryFingerprint)
```

### Entity Descriptions

| Entity | Purpose |
|--------|---------|
| `DatabaseInstance` | A SQL Server instance being monitored |
| `MonitoredDatabase` | A database within an instance, with sampling configuration |
| `QueryFingerprint` | A normalized query pattern (query_hash from SQL Server) |
| `ExecutionPlanSnapshot` | A captured execution plan with characteristics (scans, seeks, etc.) |
| `PlanMetricSample` | Point-in-time performance metrics (CPU, duration, reads) |
| `PlanBaseline` | Expected "good" performance for regression comparison |
| `RegressionEvent` | A detected performance degradation with workflow status |
| `RemediationSuggestion` | An actionable fix with optional T-SQL script |
| `Hotspot` | A top resource-consuming query in a time window |

## Value Objects

| Value Object | Purpose |
|--------------|---------|
| `TimeWindow` | Immutable time range with helpers (`LastHours(1)`, `Contains()`) |
| `ThresholdConfiguration` | Regression thresholds with presets (`Default`, `Strict`, `Relaxed`) |
| `QueryHash` / `PlanHash` | SQL Server hash identifiers with normalization |
| `MetricsSummary` | Aggregated metrics snapshot |
| `MetricsRatio` | Comparison result (current / baseline) |
| `DatabaseIdentifier` | Server + database name pair |

## Interfaces

### IRegressionDetector
Compares current metrics against baselines.

```csharp
RegressionEvent? DetectRegression(QueryFingerprint fingerprint, IEnumerable<PlanMetricSample> samples);
```

### IHotspotDetector
Finds top resource-consuming queries.

```csharp
IReadOnlyList<Hotspot> DetectHotspots(MonitoredDatabase db, IEnumerable<PlanMetricSample> samples, ...);
```

### IRemediationAdvisor
Generates fix suggestions for regressions and hotspots.

```csharp
IReadOnlyList<RemediationSuggestion> SuggestRemediations(RegressionEvent regression);
```

## Key Design Patterns

### Aggregate Roots
- `DatabaseInstance` controls creation of `MonitoredDatabase`
- `MonitoredDatabase` controls creation of `QueryFingerprint`
- Parent entities use `internal` constructors to enforce this

### Encapsulation
- Private setters with public methods for state changes
- Collections exposed as `IReadOnlyCollection<T>`
- Business rules enforced in methods (`Deactivate()`, `Resolve()`, etc.)

### Immutable Value Objects
- All value objects are `sealed` with `private set` or `init`
- Implement `IEquatable<T>` for value-based equality
- Include factory methods (`TimeWindow.LastHours(1)`)

## Enums

| Enum | Location | Values |
|------|----------|--------|
| `RegressionType` | RegressionEvent.cs | CpuTime, Duration, LogicalReads, PlanChange, ... |
| `RegressionSeverity` | RegressionEvent.cs | Low, Medium, High, Critical |
| `RegressionStatus` | RegressionEvent.cs | New, Acknowledged, Investigating, Resolved, ... |
| `ResolutionMethod` | RegressionEvent.cs | PlanForced, IndexChange, StatisticsUpdated, ... |
| `RemediationType` | RemediationSuggestion.cs | ForcePlan, UpdateStatistics, CreateIndex, ... |
| `ActionSafetyLevel` | RemediationSuggestion.cs | Safe, RequiresReview, ManualOnly |
| `HotspotMetricType` | Hotspot.cs | TotalCpuTime, TotalLogicalReads, ... |
| `HotspotStatus` | Hotspot.cs | Active, Acknowledged, Expected, Resolved |
| `BaselineSource` | PlanBaseline.cs | AutoGenerated, ManuallySet, QueryStoreImport |
| `MetricType` | PlanMetricSample.cs | CpuTime, Duration, LogicalReads, ... |

## Usage Examples

### Creating a monitored database
```csharp
var instance = new DatabaseInstance("PROD-SQL-01", "Production Server", "Production");
var database = instance.AddDatabase("OrdersDB");
database.ConfigureSampling(samplingIntervalSeconds: 60, minimumCpuTimeMs: 100, minimumLogicalReads: 1000);
```

### Registering a query and plan
```csharp
var fingerprint = database.RegisterQueryFingerprint(
    queryHash: "0x7A3B2C1D00000000",
    normalizedQueryText: "SELECT * FROM Orders WHERE CustomerId = @p1",
    objectName: "dbo.GetOrdersByCustomer");

var plan = fingerprint.AddPlanSnapshot(
    planHash: "0x1A2B3C4D00000000",
    planXml: "<ShowPlanXML>...</ShowPlanXML>",
    estimatedCost: 0.05);
```

### Recording metrics and checking for regression
```csharp
var sample = plan.AddMetricSample(
    executionCount: 1000,
    avgCpuTimeMs: 45,
    avgDurationMs: 120,
    avgLogicalReads: 15000,
    avgPhysicalReads: 50,
    avgRowsReturned: 100);

var result = fingerprint.Baseline?.CheckForRegression(sample);
if (result?.HasRegression == true)
{
    // Handle regression
}
```

### Using time windows
```csharp
var lastHour = TimeWindow.LastHours(1);
var samples = plan.MetricSamples.Where(s => lastHour.Contains(s.SampledAtUtc));
```

## Dependencies

**None.** This layer is pure C# with no NuGet packages or external references.
