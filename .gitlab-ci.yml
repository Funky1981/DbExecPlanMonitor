# GitLab CI/CD Pipeline for DbExecPlanMonitor
# Builds, tests, and optionally publishes the application

stages:
  - build
  - test
  - publish
  - release

variables:
  DOTNET_VERSION: "8.0"
  SOLUTION_PATH: "src/DbExecPlanMonitor.sln"
  DOCKER_DRIVER: overlay2
  # Disable .NET CLI telemetry
  DOTNET_CLI_TELEMETRY_OPTOUT: "1"
  DOTNET_NOLOGO: "1"

# Cache NuGet packages between jobs
.dotnet-cache: &dotnet-cache
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - ~/.nuget/packages/

# ============================================
# Build Stage
# ============================================
build:
  stage: build
  image: mcr.microsoft.com/dotnet/sdk:${DOTNET_VERSION}
  <<: *dotnet-cache
  script:
    - dotnet restore ${SOLUTION_PATH}
    - dotnet build ${SOLUTION_PATH} --configuration Release --no-restore
  artifacts:
    paths:
      - src/*/bin/Release/
      - src/*/obj/
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# ============================================
# Test Stage
# ============================================
test:
  stage: test
  image: mcr.microsoft.com/dotnet/sdk:${DOTNET_VERSION}
  <<: *dotnet-cache
  needs:
    - build
  script:
    - dotnet test ${SOLUTION_PATH} 
        --configuration Release 
        --no-build 
        --verbosity normal 
        --collect:"XPlat Code Coverage" 
        --results-directory ./coverage
        --logger "junit;LogFilePath=./test-results/test-results.xml"
  artifacts:
    when: always
    paths:
      - coverage/
      - test-results/
    reports:
      junit: test-results/test-results.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/**/coverage.cobertura.xml
    expire_in: 1 week
  coverage: '/Total\s*\|\s*(\d+(?:\.\d+)?)%/'
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# ============================================
# Code Quality (Optional - requires GitLab Ultimate)
# ============================================
code-quality:
  stage: test
  image: mcr.microsoft.com/dotnet/sdk:${DOTNET_VERSION}
  <<: *dotnet-cache
  needs:
    - build
  script:
    - dotnet tool restore || dotnet tool install --global dotnet-format
    - dotnet format ${SOLUTION_PATH} --verify-no-changes --verbosity diagnostic || true
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ============================================
# Build Docker Image
# ============================================
docker-build:
  stage: publish
  image: docker:24
  services:
    - docker:24-dind
  needs:
    - test
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        TAG_VERSION="${CI_COMMIT_TAG}"
      else
        TAG_VERSION="${CI_COMMIT_REF_SLUG}"
      fi
    - docker build 
        --tag ${CI_REGISTRY_IMAGE}:${TAG_VERSION}
        --tag ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}
        --build-arg BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        --build-arg VCS_REF=${CI_COMMIT_SHA}
        .
    - docker push ${CI_REGISTRY_IMAGE}:${TAG_VERSION}
    - docker push ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}
    # Push 'latest' tag only for default branch
    - |
      if [ "$CI_COMMIT_BRANCH" = "$CI_DEFAULT_BRANCH" ]; then
        docker tag ${CI_REGISTRY_IMAGE}:${TAG_VERSION} ${CI_REGISTRY_IMAGE}:latest
        docker push ${CI_REGISTRY_IMAGE}:latest
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# ============================================
# Publish Windows Artifacts
# ============================================
publish-windows:
  stage: publish
  image: mcr.microsoft.com/dotnet/sdk:${DOTNET_VERSION}
  <<: *dotnet-cache
  needs:
    - test
  script:
    - dotnet publish src/DbExecPlanMonitor.Worker/DbExecPlanMonitor.Worker.csproj
        -c Release
        -r win-x64
        --self-contained false
        -o ./publish/windows
    - cp scripts/Install-WindowsService.ps1 ./publish/windows/
    - cp scripts/Uninstall-WindowsService.ps1 ./publish/windows/
    - apt-get update && apt-get install -y zip
    - cd ./publish/windows && zip -r ../../DbExecPlanMonitor-windows-x64.zip .
  artifacts:
    paths:
      - DbExecPlanMonitor-windows-x64.zip
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_TAG

# ============================================
# Publish Linux Artifacts
# ============================================
publish-linux:
  stage: publish
  image: mcr.microsoft.com/dotnet/sdk:${DOTNET_VERSION}
  <<: *dotnet-cache
  needs:
    - test
  script:
    - dotnet publish src/DbExecPlanMonitor.Worker/DbExecPlanMonitor.Worker.csproj
        -c Release
        -r linux-x64
        --self-contained false
        -o ./publish/linux
    - cp scripts/install-linux-service.sh ./publish/linux/
    - cp scripts/dbexecplanmonitor.service ./publish/linux/
    - chmod +x ./publish/linux/install-linux-service.sh
    - tar -czvf DbExecPlanMonitor-linux-x64.tar.gz -C ./publish/linux .
  artifacts:
    paths:
      - DbExecPlanMonitor-linux-x64.tar.gz
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_TAG

# ============================================
# Create GitLab Release
# ============================================
release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - publish-windows
    - publish-linux
    - docker-build
  script:
    - echo "Creating release for ${CI_COMMIT_TAG}"
  release:
    tag_name: $CI_COMMIT_TAG
    name: "Release $CI_COMMIT_TAG"
    description: |
      ## DbExecPlanMonitor Release $CI_COMMIT_TAG
      
      ### Downloads
      - Windows x64: [DbExecPlanMonitor-windows-x64.zip](${CI_PROJECT_URL}/-/jobs/artifacts/${CI_COMMIT_TAG}/raw/DbExecPlanMonitor-windows-x64.zip?job=publish-windows)
      - Linux x64: [DbExecPlanMonitor-linux-x64.tar.gz](${CI_PROJECT_URL}/-/jobs/artifacts/${CI_COMMIT_TAG}/raw/DbExecPlanMonitor-linux-x64.tar.gz?job=publish-linux)
      
      ### Docker Image
      ```
      docker pull ${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG}
      ```
    assets:
      links:
        - name: "Windows x64"
          url: "${CI_PROJECT_URL}/-/jobs/artifacts/${CI_COMMIT_TAG}/raw/DbExecPlanMonitor-windows-x64.zip?job=publish-windows"
          filepath: "/binaries/DbExecPlanMonitor-windows-x64.zip"
          link_type: package
        - name: "Linux x64"
          url: "${CI_PROJECT_URL}/-/jobs/artifacts/${CI_COMMIT_TAG}/raw/DbExecPlanMonitor-linux-x64.tar.gz?job=publish-linux"
          filepath: "/binaries/DbExecPlanMonitor-linux-x64.tar.gz"
          link_type: package
        - name: "Docker Image"
          url: "https://${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG}"
          link_type: image
  rules:
    - if: $CI_COMMIT_TAG

# ============================================
# Deploy to Staging (Manual)
# ============================================
deploy-staging:
  stage: release
  image: mcr.microsoft.com/dotnet/sdk:${DOTNET_VERSION}
  needs:
    - docker-build
  environment:
    name: staging
    url: https://staging.example.com
  script:
    - echo "Deploying ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} to staging..."
    # Add your deployment commands here
    # Example: kubectl set image deployment/dbexecplanmonitor app=${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}
  when: manual
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ============================================
# Deploy to Production (Manual)
# ============================================
deploy-production:
  stage: release
  image: mcr.microsoft.com/dotnet/sdk:${DOTNET_VERSION}
  needs:
    - deploy-staging
  environment:
    name: production
    url: https://production.example.com
  script:
    - echo "Deploying ${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG} to production..."
    # Add your deployment commands here
  when: manual
  rules:
    - if: $CI_COMMIT_TAG
